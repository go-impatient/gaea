// Package example_v1 is generated by protoc-gen-twirp v0.1.0, DO NOT EDIT.
// source: rpc/example/v1/helloworld.proto
package example_v1

import strings "strings"
import context "context"
import fmt "fmt"
import strconv "strconv"
import errors "errors"
import ioutil "io/ioutil"
import http "net/http"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import ctxkit "moocss.com/gaea/pkg/ctxkit"
import twirp "moocss.com/gaea/pkg/twirp"

// If the request does not have any number filed, the strconv
// is not needed. However, there is no easy way to drop it.
var _ = strconv.IntSize
var _ = ctxkit.GetUserID

// ====================
// Helloworld Interface
// ====================

// FIXME 服务必须写注释
type Helloworld interface {
	// FIXME 接口必须写注释
	//
	// 这里的行尾注释 sniper:foo 有特殊含义，是可选的
	// 框架会将此处冒号后面的值(foo)注入到 ctx 中，
	// 用户可以使用 twirp.MethodOption(ctx) 查询，并执行不同的逻辑
	// 这个 sniper 前缀可以通过 --twirp_out=option_prefix=sniper:. 自定义
	Echo(context.Context, *HelloworldEchoReq) (*HelloworldEchoResp, error)
}

// ==========================
// Helloworld Protobuf Client
// ==========================

type helloworldProtobufClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewHelloworldProtobufClient creates a Protobuf client that implements the Helloworld interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewHelloworldProtobufClient(addr string, client twirp.HTTPClient) Helloworld {
	prefix := addr + HelloworldPathPrefix
	urls := [1]string{
		prefix + "Echo",
	}
	return &helloworldProtobufClient{
		client: client,
		urls:   urls,
	}
}

func (c *helloworldProtobufClient) Echo(ctx context.Context, in *HelloworldEchoReq) (*HelloworldEchoResp, error) {
	ctx = twirp.WithPackageName(ctx, "example.v1")
	ctx = twirp.WithServiceName(ctx, "Helloworld")
	ctx = twirp.WithMethodName(ctx, "Echo")
	out := new(HelloworldEchoResp)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ======================
// Helloworld JSON Client
// ======================

type helloworldJSONClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewHelloworldJSONClient creates a JSON client that implements the Helloworld interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewHelloworldJSONClient(addr string, client twirp.HTTPClient) Helloworld {
	prefix := addr + HelloworldPathPrefix
	urls := [1]string{
		prefix + "Echo",
	}
	return &helloworldJSONClient{
		client: client,
		urls:   urls,
	}
}

func (c *helloworldJSONClient) Echo(ctx context.Context, in *HelloworldEchoReq) (*HelloworldEchoResp, error) {
	ctx = twirp.WithPackageName(ctx, "example.v1")
	ctx = twirp.WithServiceName(ctx, "Helloworld")
	ctx = twirp.WithMethodName(ctx, "Echo")
	out := new(HelloworldEchoResp)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// =========================
// Helloworld Server Handler
// =========================

type helloworldServer struct {
	Helloworld
	hooks *twirp.ServerHooks
}

func NewHelloworldServer(svc Helloworld, hooks *twirp.ServerHooks) twirp.Server {
	return &helloworldServer{
		Helloworld: svc,
		hooks:      hooks,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *helloworldServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	s.hooks.WriteError(ctx, resp, err)
}

// badRouteError is used when the twirp server cannot route a request
func (s *helloworldServer) badRouteError(msg string, method, url string) twirp.Error {
	err := twirp.NewError(twirp.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

func (s *helloworldServer) wrapErr(err error, msg string) error {
	return errors.New(msg + ": " + err.Error())
}

// HelloworldPathPrefix is used for all URL paths on a twirp Helloworld server.
// Requests are always: POST HelloworldPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const HelloworldPathPrefix = "/example.v1.Helloworld/"

func (s *helloworldServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = twirp.WithHttpRequest(ctx, req)
	ctx = twirp.WithPackageName(ctx, "example.v1")
	ctx = twirp.WithServiceName(ctx, "Helloworld")
	ctx = twirp.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = s.hooks.CallRequestReceived(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" && !twirp.AllowGET(ctx) {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}

	switch req.URL.Path {
	case "/example.v1.Helloworld/Echo":
		s.serveEcho(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}
}

func (s *helloworldServer) serveEcho(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	ctx = twirp.WithMethodOption(ctx, "foo")
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveEchoJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveEchoProtobuf(ctx, resp, req)
	default:
		s.serveEchoForm(ctx, resp, req)
	}
}

func (s *helloworldServer) serveEchoJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "Echo")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(HelloworldEchoReq)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	if validerr := reqContent.validate(); validerr != nil {
		s.writeError(ctx, resp, twirp.InvalidArgumentError("argument", validerr.Error()))
		return
	}

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Helloworld.Echo(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *HelloworldEchoResp and nil error while calling Echo. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *helloworldServer) serveEchoProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "Echo")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(HelloworldEchoReq)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	if validerr := reqContent.validate(); validerr != nil {
		s.writeError(ctx, resp, twirp.InvalidArgumentError("argument", validerr.Error()))
		return
	}

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Helloworld.Echo(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *HelloworldEchoResp and nil error while calling Echo. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *helloworldServer) serveEchoForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "Echo")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(HelloworldEchoReq)

	if v, ok := req.Form["msg"]; ok {
		reqContent.Msg = v[0]
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	if validerr := reqContent.validate(); validerr != nil {
		s.writeError(ctx, resp, twirp.InvalidArgumentError("argument", validerr.Error()))
		return
	}

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Helloworld.Echo(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *HelloworldEchoResp and nil error while calling Echo. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *helloworldServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0SHA845cca13aa512af651a0c95a642634d408f39273, 0
}

func (s *helloworldServer) ProtocGenTwirpVersion() string {
	return "v0.1.0"
}

var twirpFileDescriptor0SHA845cca13aa512af651a0c95a642634d408f39273 = []byte{
	// 136 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x2f, 0x2a, 0x48, 0xd6,
	0x4f, 0xad, 0x48, 0xcc, 0x2d, 0xc8, 0x49, 0xd5, 0x2f, 0x33, 0xd4, 0xcf, 0x48, 0xcd, 0xc9, 0xc9,
	0x2f, 0xcf, 0x2f, 0xca, 0x49, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0xe2, 0x82, 0x4a, 0xea,
	0x95, 0x19, 0x2a, 0xa9, 0x72, 0x09, 0x7a, 0xc0, 0xe5, 0x5d, 0x93, 0x33, 0xf2, 0x83, 0x52, 0x0b,
	0x85, 0x04, 0xb8, 0x98, 0x73, 0x8b, 0xd3, 0x25, 0x18, 0x15, 0x18, 0x35, 0x38, 0x83, 0x40, 0x4c,
	0x25, 0x35, 0x2e, 0x21, 0x74, 0x65, 0xc5, 0x05, 0x98, 0xea, 0x8c, 0x82, 0xb9, 0xb8, 0x10, 0xea,
	0x84, 0x5c, 0xb9, 0x58, 0x40, 0x6a, 0x85, 0x64, 0xf5, 0x10, 0x36, 0xea, 0x61, 0x58, 0x27, 0x25,
	0x87, 0x4f, 0xba, 0xb8, 0x20, 0x89, 0x0d, 0xec, 0x6c, 0x63, 0x40, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x3a, 0xb0, 0xfb, 0x45, 0xd9, 0x00, 0x00, 0x00,
}

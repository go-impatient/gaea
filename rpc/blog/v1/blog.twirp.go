// Package blog_v1 is generated by protoc-gen-twirp v0.1.0, DO NOT EDIT.
// source: blog.proto
package blog_v1

import strings "strings"
import context "context"
import fmt "fmt"
import strconv "strconv"
import errors "errors"
import ioutil "io/ioutil"
import http "net/http"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import ctxkit "moocss.com/gaea/pkg/ctxkit"
import twirp "moocss.com/gaea/pkg/twirp"

// If the request does not have any number filed, the strconv
// is not needed. However, there is no easy way to drop it.
var _ = strconv.IntSize
var _ = ctxkit.GetUserID

// ==============
// Blog Interface
// ==============

// 博客服务
type Blog interface {
	// 创建文章
	CreateArticle(context.Context, *CreateArticleRequest) (*CreateArticleReply, error)

	// 更新文章
	UpdateArticle(context.Context, *UpdateArticleRequest) (*UpdateArticleReply, error)

	// 删除文章
	DeleteArticle(context.Context, *DeleteArticleRequest) (*DeleteArticleReply, error)

	// 获取文章
	GetArticle(context.Context, *GetArticleRequest) (*GetArticleReply, error)

	// 获取文章列表
	ListArticle(context.Context, *ListArticleRequest) (*ListArticleReply, error)
}

// ====================
// Blog Protobuf Client
// ====================

type blogProtobufClient struct {
	client twirp.HTTPClient
	urls   [5]string
}

// NewBlogProtobufClient creates a Protobuf client that implements the Blog interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewBlogProtobufClient(addr string, client twirp.HTTPClient) Blog {
	prefix := addr + BlogPathPrefix
	urls := [5]string{
		prefix + "CreateArticle",
		prefix + "UpdateArticle",
		prefix + "DeleteArticle",
		prefix + "GetArticle",
		prefix + "ListArticle",
	}
	return &blogProtobufClient{
		client: client,
		urls:   urls,
	}
}

func (c *blogProtobufClient) CreateArticle(ctx context.Context, in *CreateArticleRequest) (*CreateArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "CreateArticle")
	out := new(CreateArticleReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogProtobufClient) UpdateArticle(ctx context.Context, in *UpdateArticleRequest) (*UpdateArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "UpdateArticle")
	out := new(UpdateArticleReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[1], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogProtobufClient) DeleteArticle(ctx context.Context, in *DeleteArticleRequest) (*DeleteArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "DeleteArticle")
	out := new(DeleteArticleReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[2], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogProtobufClient) GetArticle(ctx context.Context, in *GetArticleRequest) (*GetArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "GetArticle")
	out := new(GetArticleReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[3], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogProtobufClient) ListArticle(ctx context.Context, in *ListArticleRequest) (*ListArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "ListArticle")
	out := new(ListArticleReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[4], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ================
// Blog JSON Client
// ================

type blogJSONClient struct {
	client twirp.HTTPClient
	urls   [5]string
}

// NewBlogJSONClient creates a JSON client that implements the Blog interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewBlogJSONClient(addr string, client twirp.HTTPClient) Blog {
	prefix := addr + BlogPathPrefix
	urls := [5]string{
		prefix + "CreateArticle",
		prefix + "UpdateArticle",
		prefix + "DeleteArticle",
		prefix + "GetArticle",
		prefix + "ListArticle",
	}
	return &blogJSONClient{
		client: client,
		urls:   urls,
	}
}

func (c *blogJSONClient) CreateArticle(ctx context.Context, in *CreateArticleRequest) (*CreateArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "CreateArticle")
	out := new(CreateArticleReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogJSONClient) UpdateArticle(ctx context.Context, in *UpdateArticleRequest) (*UpdateArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "UpdateArticle")
	out := new(UpdateArticleReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[1], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogJSONClient) DeleteArticle(ctx context.Context, in *DeleteArticleRequest) (*DeleteArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "DeleteArticle")
	out := new(DeleteArticleReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[2], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogJSONClient) GetArticle(ctx context.Context, in *GetArticleRequest) (*GetArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "GetArticle")
	out := new(GetArticleReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[3], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *blogJSONClient) ListArticle(ctx context.Context, in *ListArticleRequest) (*ListArticleReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithMethodName(ctx, "ListArticle")
	out := new(ListArticleReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[4], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ===================
// Blog Server Handler
// ===================

type blogServer struct {
	Blog
	hooks *twirp.ServerHooks
}

func NewBlogServer(svc Blog, hooks *twirp.ServerHooks) twirp.Server {
	return &blogServer{
		Blog:  svc,
		hooks: hooks,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *blogServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	s.hooks.WriteError(ctx, resp, err)
}

// badRouteError is used when the twirp server cannot route a request
func (s *blogServer) badRouteError(msg string, method, url string) twirp.Error {
	err := twirp.NewError(twirp.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

func (s *blogServer) wrapErr(err error, msg string) error {
	return errors.New(msg + ": " + err.Error())
}

// BlogPathPrefix is used for all URL paths on a twirp Blog server.
// Requests are always: POST BlogPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const BlogPathPrefix = "/blog.v1.Blog/"

func (s *blogServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = twirp.WithHttpRequest(ctx, req)
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Blog")
	ctx = twirp.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = s.hooks.CallRequestReceived(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" && !twirp.AllowGET(ctx) {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}

	switch req.URL.Path {
	case "/blog.v1.Blog/CreateArticle":
		s.serveCreateArticle(ctx, resp, req)
		return
	case "/blog.v1.Blog/UpdateArticle":
		s.serveUpdateArticle(ctx, resp, req)
		return
	case "/blog.v1.Blog/DeleteArticle":
		s.serveDeleteArticle(ctx, resp, req)
		return
	case "/blog.v1.Blog/GetArticle":
		s.serveGetArticle(ctx, resp, req)
		return
	case "/blog.v1.Blog/ListArticle":
		s.serveListArticle(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}
}

func (s *blogServer) serveCreateArticle(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveCreateArticleJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveCreateArticleProtobuf(ctx, resp, req)
	default:
		s.serveCreateArticleForm(ctx, resp, req)
	}
}

func (s *blogServer) serveCreateArticleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "CreateArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(CreateArticleRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.CreateArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateArticleReply and nil error while calling CreateArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveCreateArticleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "CreateArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(CreateArticleRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.CreateArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateArticleReply and nil error while calling CreateArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveCreateArticleForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "CreateArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(CreateArticleRequest)

	if v, ok := req.Form["title"]; ok {
		reqContent.Title = v[0]
	}
	if v, ok := req.Form["content"]; ok {
		reqContent.Content = v[0]
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.CreateArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreateArticleReply and nil error while calling CreateArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveUpdateArticle(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveUpdateArticleJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveUpdateArticleProtobuf(ctx, resp, req)
	default:
		s.serveUpdateArticleForm(ctx, resp, req)
	}
}

func (s *blogServer) serveUpdateArticleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "UpdateArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(UpdateArticleRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.UpdateArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateArticleReply and nil error while calling UpdateArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveUpdateArticleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "UpdateArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(UpdateArticleRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.UpdateArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateArticleReply and nil error while calling UpdateArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveUpdateArticleForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "UpdateArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(UpdateArticleRequest)

	if v, ok := req.Form["id"]; ok {
		vv, err := strconv.ParseInt(v[0], 10, 64)
		if err != nil {
			s.writeError(ctx, resp, twirp.InvalidArgumentError("id", err.Error()))
			return
		}
		reqContent.Id = int64(vv)
	}
	if v, ok := req.Form["title"]; ok {
		reqContent.Title = v[0]
	}
	if v, ok := req.Form["content"]; ok {
		reqContent.Content = v[0]
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.UpdateArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdateArticleReply and nil error while calling UpdateArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveDeleteArticle(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveDeleteArticleJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveDeleteArticleProtobuf(ctx, resp, req)
	default:
		s.serveDeleteArticleForm(ctx, resp, req)
	}
}

func (s *blogServer) serveDeleteArticleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "DeleteArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(DeleteArticleRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.DeleteArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteArticleReply and nil error while calling DeleteArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveDeleteArticleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "DeleteArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(DeleteArticleRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.DeleteArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteArticleReply and nil error while calling DeleteArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveDeleteArticleForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "DeleteArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(DeleteArticleRequest)

	if v, ok := req.Form["id"]; ok {
		vv, err := strconv.ParseInt(v[0], 10, 64)
		if err != nil {
			s.writeError(ctx, resp, twirp.InvalidArgumentError("id", err.Error()))
			return
		}
		reqContent.Id = int64(vv)
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.DeleteArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeleteArticleReply and nil error while calling DeleteArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveGetArticle(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetArticleJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetArticleProtobuf(ctx, resp, req)
	default:
		s.serveGetArticleForm(ctx, resp, req)
	}
}

func (s *blogServer) serveGetArticleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "GetArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(GetArticleRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.GetArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetArticleReply and nil error while calling GetArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveGetArticleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "GetArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(GetArticleRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.GetArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetArticleReply and nil error while calling GetArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveGetArticleForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "GetArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(GetArticleRequest)

	if v, ok := req.Form["id"]; ok {
		vv, err := strconv.ParseInt(v[0], 10, 64)
		if err != nil {
			s.writeError(ctx, resp, twirp.InvalidArgumentError("id", err.Error()))
			return
		}
		reqContent.Id = int64(vv)
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.GetArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetArticleReply and nil error while calling GetArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveListArticle(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveListArticleJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveListArticleProtobuf(ctx, resp, req)
	default:
		s.serveListArticleForm(ctx, resp, req)
	}
}

func (s *blogServer) serveListArticleJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "ListArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(ListArticleRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.ListArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListArticleReply and nil error while calling ListArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveListArticleProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "ListArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(ListArticleRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.ListArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListArticleReply and nil error while calling ListArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) serveListArticleForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "ListArticle")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(ListArticleRequest)

	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Blog.ListArticle(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListArticleReply and nil error while calling ListArticle. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *blogServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0SHA20f5adb6295b89b43ea2786e2f56e4c7eed24f50, 0
}

func (s *blogServer) ProtocGenTwirpVersion() string {
	return "v0.1.0"
}

var twirpFileDescriptor0SHA20f5adb6295b89b43ea2786e2f56e4c7eed24f50 = []byte{
	// 348 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xcf, 0x4b, 0xfb, 0x40,
	0x10, 0xc5, 0x49, 0xda, 0xef, 0xb7, 0x38, 0xa5, 0x5a, 0x87, 0x3d, 0xac, 0x11, 0xa1, 0xac, 0x20,
	0xc5, 0x43, 0xc1, 0x7a, 0x56, 0xb4, 0xfe, 0x3a, 0xd4, 0x53, 0x41, 0x6f, 0x1e, 0x6c, 0x3b, 0x94,
	0xc5, 0xa5, 0x89, 0xc9, 0x56, 0xe8, 0x7f, 0xee, 0x51, 0xba, 0xa6, 0xc9, 0x26, 0xd9, 0x52, 0x8a,
	0xb7, 0xdd, 0x9d, 0xb7, 0x9f, 0x79, 0x3b, 0x2f, 0x04, 0x60, 0xac, 0xc2, 0x59, 0x2f, 0x8a, 0x43,
	0x1d, 0x62, 0xc3, 0xac, 0xbf, 0x2e, 0xc4, 0x1b, 0x34, 0x6e, 0x63, 0x2d, 0x27, 0x8a, 0x70, 0x1f,
	0x7c, 0x39, 0xe5, 0x5e, 0xc7, 0xeb, 0xd6, 0x46, 0xbe, 0x9c, 0x22, 0x83, 0x7f, 0x5a, 0x6a, 0x45,
	0xdc, 0xef, 0x78, 0xdd, 0xbd, 0xd1, 0xef, 0x06, 0x39, 0x34, 0x26, 0xe1, 0x5c, 0xd3, 0x5c, 0xf3,
	0x9a, 0x39, 0x5f, 0x6f, 0x11, 0xa1, 0xae, 0xe4, 0x07, 0xf1, 0xba, 0x21, 0x98, 0xb5, 0x78, 0x04,
	0x76, 0x17, 0xd3, 0xbb, 0xa6, 0xb4, 0xc9, 0x88, 0x3e, 0x17, 0x94, 0xe8, 0x9c, 0xed, 0x6d, 0x60,
	0xfb, 0x05, 0xb6, 0xb8, 0x01, 0x2c, 0x71, 0x22, 0xb5, 0xc4, 0xf3, 0xcc, 0xbc, 0xe1, 0x34, 0xfb,
	0xed, 0x5e, 0xfa, 0xae, 0xde, 0x5a, 0xb7, 0x16, 0x88, 0x57, 0x60, 0x2f, 0xd1, 0xb4, 0xea, 0xe4,
	0x8f, 0xaf, 0x5e, 0x39, 0x2b, 0x71, 0x77, 0x75, 0x76, 0x06, 0xec, 0x9e, 0x14, 0x6d, 0x73, 0x26,
	0x18, 0x60, 0x49, 0x17, 0xa9, 0xa5, 0x38, 0x85, 0xc3, 0x27, 0xd2, 0x5b, 0xae, 0x5e, 0xc1, 0x81,
	0x2d, 0xda, 0xd5, 0x21, 0x03, 0x7c, 0x96, 0x49, 0xa9, 0x89, 0xb8, 0x86, 0x76, 0xe1, 0x34, 0xa5,
	0xc6, 0x94, 0x2c, 0x94, 0x4e, 0xb8, 0xd7, 0xa9, 0xb9, 0xa9, 0xa9, 0xa0, 0xff, 0xed, 0x43, 0x7d,
	0xa0, 0xc2, 0x19, 0x0e, 0xa1, 0x55, 0x08, 0x17, 0x4f, 0xb2, 0x4b, 0xae, 0x8f, 0x27, 0x38, 0xde,
	0x54, 0x5e, 0x39, 0x18, 0x42, 0xab, 0x90, 0x87, 0x05, 0x73, 0xe5, 0x6f, 0xc1, 0x1c, 0x31, 0x0e,
	0xa1, 0x55, 0x18, 0xb9, 0x05, 0x73, 0x45, 0x66, 0xc1, 0xaa, 0x49, 0xe1, 0x00, 0x20, 0x0f, 0x01,
	0x83, 0x4c, 0x5a, 0x89, 0x2f, 0xe0, 0xce, 0xda, 0x8a, 0xf1, 0x00, 0x4d, 0x6b, 0xe6, 0x98, 0xf7,
	0xab, 0xe6, 0x13, 0x1c, 0xb9, 0x8b, 0x91, 0x5a, 0x8e, 0xff, 0x9b, 0xbf, 0xc0, 0xe5, 0x4f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x61, 0xb8, 0x45, 0x6c, 0x13, 0x04, 0x00, 0x00,
}

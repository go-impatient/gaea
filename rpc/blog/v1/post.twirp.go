// Package blog_v1 is generated by protoc-gen-twirp v0.1.0, DO NOT EDIT.
// source: post.proto
package blog_v1

import strings "strings"
import context "context"
import fmt "fmt"
import strconv "strconv"
import errors "errors"
import ioutil "io/ioutil"
import http "net/http"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import ctxkit "moocss.com/gaea/pkg/ctxkit"
import twirp "moocss.com/gaea/pkg/twirp"

// If the request does not have any number filed, the strconv
// is not needed. However, there is no easy way to drop it.
var _ = strconv.IntSize
var _ = ctxkit.GetUserID

// ==============
// Post Interface
// ==============

// 文章服务
type Post interface {
	// 创建文章
	CreatePost(context.Context, *CreatePostRequest) (*CreatePostReply, error)

	// 更新文章
	UpdatePost(context.Context, *UpdatePostRequest) (*UpdatePostReply, error)

	// 删除文章
	DeletePost(context.Context, *DeletePostRequest) (*DeletePostReply, error)

	// 获取文章
	GetPost(context.Context, *GetPostRequest) (*GetPostReply, error)

	// 获取文章列表
	ListPost(context.Context, *ListPostRequest) (*ListPostReply, error)
}

// ====================
// Post Protobuf Client
// ====================

type postProtobufClient struct {
	client twirp.HTTPClient
	urls   [5]string
}

// NewPostProtobufClient creates a Protobuf client that implements the Post interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewPostProtobufClient(addr string, client twirp.HTTPClient) Post {
	prefix := addr + PostPathPrefix
	urls := [5]string{
		prefix + "CreatePost",
		prefix + "UpdatePost",
		prefix + "DeletePost",
		prefix + "GetPost",
		prefix + "ListPost",
	}
	return &postProtobufClient{
		client: client,
		urls:   urls,
	}
}

func (c *postProtobufClient) CreatePost(ctx context.Context, in *CreatePostRequest) (*CreatePostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "CreatePost")
	out := new(CreatePostReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postProtobufClient) UpdatePost(ctx context.Context, in *UpdatePostRequest) (*UpdatePostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "UpdatePost")
	out := new(UpdatePostReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[1], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postProtobufClient) DeletePost(ctx context.Context, in *DeletePostRequest) (*DeletePostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "DeletePost")
	out := new(DeletePostReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[2], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postProtobufClient) GetPost(ctx context.Context, in *GetPostRequest) (*GetPostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "GetPost")
	out := new(GetPostReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[3], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postProtobufClient) ListPost(ctx context.Context, in *ListPostRequest) (*ListPostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "ListPost")
	out := new(ListPostReply)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[4], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ================
// Post JSON Client
// ================

type postJSONClient struct {
	client twirp.HTTPClient
	urls   [5]string
}

// NewPostJSONClient creates a JSON client that implements the Post interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewPostJSONClient(addr string, client twirp.HTTPClient) Post {
	prefix := addr + PostPathPrefix
	urls := [5]string{
		prefix + "CreatePost",
		prefix + "UpdatePost",
		prefix + "DeletePost",
		prefix + "GetPost",
		prefix + "ListPost",
	}
	return &postJSONClient{
		client: client,
		urls:   urls,
	}
}

func (c *postJSONClient) CreatePost(ctx context.Context, in *CreatePostRequest) (*CreatePostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "CreatePost")
	out := new(CreatePostReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postJSONClient) UpdatePost(ctx context.Context, in *UpdatePostRequest) (*UpdatePostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "UpdatePost")
	out := new(UpdatePostReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[1], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postJSONClient) DeletePost(ctx context.Context, in *DeletePostRequest) (*DeletePostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "DeletePost")
	out := new(DeletePostReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[2], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postJSONClient) GetPost(ctx context.Context, in *GetPostRequest) (*GetPostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "GetPost")
	out := new(GetPostReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[3], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *postJSONClient) ListPost(ctx context.Context, in *ListPostRequest) (*ListPostReply, error) {
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithMethodName(ctx, "ListPost")
	out := new(ListPostReply)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[4], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ===================
// Post Server Handler
// ===================

type postServer struct {
	Post
	hooks *twirp.ServerHooks
}

func NewPostServer(svc Post, hooks *twirp.ServerHooks) twirp.Server {
	return &postServer{
		Post:  svc,
		hooks: hooks,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *postServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	s.hooks.WriteError(ctx, resp, err)
}

// badRouteError is used when the twirp server cannot route a request
func (s *postServer) badRouteError(msg string, method, url string) twirp.Error {
	err := twirp.NewError(twirp.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

func (s *postServer) wrapErr(err error, msg string) error {
	return errors.New(msg + ": " + err.Error())
}

// PostPathPrefix is used for all URL paths on a twirp Post server.
// Requests are always: POST PostPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const PostPathPrefix = "/blog.v1.Post/"

func (s *postServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = twirp.WithHttpRequest(ctx, req)
	ctx = twirp.WithPackageName(ctx, "blog.v1")
	ctx = twirp.WithServiceName(ctx, "Post")
	ctx = twirp.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = s.hooks.CallRequestReceived(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" && !twirp.AllowGET(ctx) {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}

	switch req.URL.Path {
	case "/blog.v1.Post/CreatePost":
		s.serveCreatePost(ctx, resp, req)
		return
	case "/blog.v1.Post/UpdatePost":
		s.serveUpdatePost(ctx, resp, req)
		return
	case "/blog.v1.Post/DeletePost":
		s.serveDeletePost(ctx, resp, req)
		return
	case "/blog.v1.Post/GetPost":
		s.serveGetPost(ctx, resp, req)
		return
	case "/blog.v1.Post/ListPost":
		s.serveListPost(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}
}

func (s *postServer) serveCreatePost(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveCreatePostJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveCreatePostProtobuf(ctx, resp, req)
	default:
		s.serveCreatePostForm(ctx, resp, req)
	}
}

func (s *postServer) serveCreatePostJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "CreatePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(CreatePostRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.CreatePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreatePostReply and nil error while calling CreatePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveCreatePostProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "CreatePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(CreatePostRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.CreatePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreatePostReply and nil error while calling CreatePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveCreatePostForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "CreatePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(CreatePostRequest)

	if v, ok := req.Form["title"]; ok {
		reqContent.Title = v[0]
	}
	if v, ok := req.Form["content"]; ok {
		reqContent.Content = v[0]
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.CreatePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *CreatePostReply and nil error while calling CreatePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveUpdatePost(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveUpdatePostJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveUpdatePostProtobuf(ctx, resp, req)
	default:
		s.serveUpdatePostForm(ctx, resp, req)
	}
}

func (s *postServer) serveUpdatePostJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "UpdatePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(UpdatePostRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.UpdatePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdatePostReply and nil error while calling UpdatePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveUpdatePostProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "UpdatePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(UpdatePostRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.UpdatePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdatePostReply and nil error while calling UpdatePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveUpdatePostForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "UpdatePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(UpdatePostRequest)

	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.UpdatePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UpdatePostReply and nil error while calling UpdatePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveDeletePost(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveDeletePostJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveDeletePostProtobuf(ctx, resp, req)
	default:
		s.serveDeletePostForm(ctx, resp, req)
	}
}

func (s *postServer) serveDeletePostJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "DeletePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(DeletePostRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.DeletePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeletePostReply and nil error while calling DeletePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveDeletePostProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "DeletePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(DeletePostRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.DeletePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeletePostReply and nil error while calling DeletePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveDeletePostForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "DeletePost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(DeletePostRequest)

	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.DeletePost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *DeletePostReply and nil error while calling DeletePost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveGetPost(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveGetPostJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveGetPostProtobuf(ctx, resp, req)
	default:
		s.serveGetPostForm(ctx, resp, req)
	}
}

func (s *postServer) serveGetPostJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "GetPost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(GetPostRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.GetPost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetPostReply and nil error while calling GetPost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveGetPostProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "GetPost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(GetPostRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.GetPost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetPostReply and nil error while calling GetPost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveGetPostForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "GetPost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(GetPostRequest)

	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.GetPost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *GetPostReply and nil error while calling GetPost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveListPost(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveListPostJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveListPostProtobuf(ctx, resp, req)
	default:
		s.serveListPostForm(ctx, resp, req)
	}
}

func (s *postServer) serveListPostJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "ListPost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(ListPostRequest)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.ListPost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListPostReply and nil error while calling ListPost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveListPostProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "ListPost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(ListPostRequest)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.ListPost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListPostReply and nil error while calling ListPost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) serveListPostForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "ListPost")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(ListPostRequest)

	ctx = twirp.WithRequest(ctx, reqContent)

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.Post.ListPost(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *ListPostReply and nil error while calling ListPost. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *postServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0SHAfbeade167182f315783403883a4e906600f7b7c3, 0
}

func (s *postServer) ProtocGenTwirpVersion() string {
	return "v0.1.0"
}

var twirpFileDescriptor0SHAfbeade167182f315783403883a4e906600f7b7c3 = []byte{
	// 261 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0x4a, 0xc3, 0x40,
	0x10, 0xc6, 0x69, 0x51, 0xa3, 0x1f, 0xda, 0x98, 0xf1, 0x5f, 0xc8, 0x49, 0x72, 0xf2, 0x14, 0x50,
	0x4f, 0x82, 0x27, 0x2b, 0x78, 0xf1, 0x20, 0x05, 0x1f, 0xc0, 0xea, 0x20, 0x85, 0xa5, 0xbb, 0x36,
	0xa3, 0x90, 0x67, 0xf4, 0xa5, 0x64, 0x6b, 0xda, 0x9d, 0x64, 0x73, 0x9c, 0x6f, 0xbe, 0xfc, 0x92,
	0xf9, 0x11, 0xc0, 0xd9, 0x5a, 0x2a, 0xb7, 0xb2, 0x62, 0x29, 0x99, 0x1b, 0xfb, 0x59, 0xfd, 0x5c,
	0x97, 0x53, 0x64, 0xd3, 0x15, 0xbf, 0x09, 0xbf, 0xd8, 0x5a, 0x66, 0xfc, 0xf5, 0xcd, 0xb5, 0xd0,
	0x29, 0x76, 0x65, 0x21, 0x86, 0xf3, 0xd1, 0xe5, 0xe8, 0xea, 0x60, 0xf6, 0x3f, 0x50, 0x8e, 0xe4,
	0xdd, 0x2e, 0x85, 0x97, 0x92, 0x8f, 0xd7, 0xf9, 0x66, 0x2c, 0x33, 0xa4, 0x1a, 0xe2, 0x4c, 0x53,
	0x9e, 0x20, 0x7b, 0x75, 0x1f, 0x5d, 0xae, 0xef, 0xe9, 0xb0, 0xed, 0x3d, 0xb2, 0xe1, 0xa8, 0xa7,
	0x43, 0xdf, 0x3b, 0xc6, 0xe4, 0x89, 0x45, 0x97, 0x26, 0x38, 0xdc, 0x26, 0xbe, 0x91, 0x21, 0x7d,
	0x5e, 0xd4, 0x9d, 0x4a, 0x8a, 0xa3, 0x10, 0x39, 0xd3, 0xdc, 0xfc, 0x8e, 0xb1, 0xe3, 0x27, 0x7a,
	0x00, 0xc2, 0x17, 0x53, 0x51, 0xb5, 0x3a, 0xaa, 0xc8, 0x45, 0x91, 0x0f, 0xee, 0x9c, 0x69, 0x3c,
	0x23, 0x5c, 0xa3, 0x18, 0xd1, 0xdd, 0x8a, 0xd1, 0x3b, 0xdf, 0x33, 0xc2, 0xa5, 0x8a, 0x11, 0x39,
	0x51, 0x8c, 0x9e, 0x1a, 0xba, 0x43, 0xd2, 0x8a, 0xa0, 0x8b, 0x6d, 0xa9, 0x2b, 0xab, 0x38, 0x8b,
	0x17, 0xfe, 0xd1, 0x7b, 0xec, 0x6f, 0x04, 0x51, 0x78, 0x41, 0x4f, 0x63, 0x71, 0x3e, 0xb0, 0x71,
	0xa6, 0x99, 0xef, 0xad, 0xff, 0xa5, 0xdb, 0xbf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xde, 0xeb, 0xe4,
	0xc3, 0x59, 0x02, 0x00, 0x00,
}

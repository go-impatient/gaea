// Package user_v1 is generated by protoc-gen-twirp v0.1.0, DO NOT EDIT.
// source: rpc/user/v1/user.proto
package user_v1

import strings "strings"
import context "context"
import fmt "fmt"
import strconv "strconv"
import errors "errors"
import ioutil "io/ioutil"
import http "net/http"

import protojson "google.golang.org/protobuf/encoding/protojson"
import proto "google.golang.org/protobuf/proto"
import ctxkit "moocss.com/gaea/pkg/ctxkit"
import twirp "moocss.com/gaea/pkg/twirp"

// If the request does not have any number filed, the strconv
// is not needed. However, there is no easy way to drop it.
var _ = strconv.IntSize
var _ = ctxkit.GetUserID

// ==============
// User Interface
// ==============

// FIXME 服务必须写注释
type User interface {
	// FIXME 接口必须写注释
	//
	// 这里的行尾注释 sniper:foo 有特殊含义，是可选的
	// 框架会将此处冒号后面的值(foo)注入到 ctx 中，
	// 用户可以使用 twirp.MethodOption(ctx) 查询，并执行不同的逻辑
	// 这个 sniper 前缀可以通过 --twirp_out=option_prefix=sniper:. 自定义
	Echo(context.Context, *UserEchoReq) (*UserEchoResp, error)
}

// ====================
// User Protobuf Client
// ====================

type userProtobufClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewUserProtobufClient creates a Protobuf client that implements the User interface.
// It communicates using Protobuf and can be configured with a custom HTTPClient.
func NewUserProtobufClient(addr string, client twirp.HTTPClient) User {
	prefix := addr + UserPathPrefix
	urls := [1]string{
		prefix + "Echo",
	}
	return &userProtobufClient{
		client: client,
		urls:   urls,
	}
}

func (c *userProtobufClient) Echo(ctx context.Context, in *UserEchoReq) (*UserEchoResp, error) {
	ctx = twirp.WithPackageName(ctx, "user.v1")
	ctx = twirp.WithServiceName(ctx, "User")
	ctx = twirp.WithMethodName(ctx, "Echo")
	out := new(UserEchoResp)
	err := twirp.DoProtobufRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ================
// User JSON Client
// ================

type userJSONClient struct {
	client twirp.HTTPClient
	urls   [1]string
}

// NewUserJSONClient creates a JSON client that implements the User interface.
// It communicates using JSON and can be configured with a custom HTTPClient.
func NewUserJSONClient(addr string, client twirp.HTTPClient) User {
	prefix := addr + UserPathPrefix
	urls := [1]string{
		prefix + "Echo",
	}
	return &userJSONClient{
		client: client,
		urls:   urls,
	}
}

func (c *userJSONClient) Echo(ctx context.Context, in *UserEchoReq) (*UserEchoResp, error) {
	ctx = twirp.WithPackageName(ctx, "user.v1")
	ctx = twirp.WithServiceName(ctx, "User")
	ctx = twirp.WithMethodName(ctx, "Echo")
	out := new(UserEchoResp)
	err := twirp.DoJSONRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ===================
// User Server Handler
// ===================

type userServer struct {
	User
	hooks *twirp.ServerHooks
}

func NewUserServer(svc User, hooks *twirp.ServerHooks) twirp.Server {
	return &userServer{
		User:  svc,
		hooks: hooks,
	}
}

// writeError writes an HTTP response with a valid Twirp error format, and triggers hooks.
// If err is not a twirp.Error, it will get wrapped with twirp.InternalErrorWith(err)
func (s *userServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	s.hooks.WriteError(ctx, resp, err)
}

// badRouteError is used when the twirp server cannot route a request
func (s *userServer) badRouteError(msg string, method, url string) twirp.Error {
	err := twirp.NewError(twirp.BadRoute, msg)
	err = err.WithMeta("twirp_invalid_route", method+" "+url)
	return err
}

func (s *userServer) wrapErr(err error, msg string) error {
	return errors.New(msg + ": " + err.Error())
}

// UserPathPrefix is used for all URL paths on a twirp User server.
// Requests are always: POST UserPathPrefix/method
// It can be used in an HTTP mux to route twirp requests along with non-twirp requests on other routes.
const UserPathPrefix = "/user.v1.User/"

func (s *userServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = twirp.WithHttpRequest(ctx, req)
	ctx = twirp.WithPackageName(ctx, "user.v1")
	ctx = twirp.WithServiceName(ctx, "User")
	ctx = twirp.WithResponseWriter(ctx, resp)

	var err error
	ctx, err = s.hooks.CallRequestReceived(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != "POST" && !twirp.AllowGET(ctx) {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}

	switch req.URL.Path {
	case "/user.v1.User/Echo":
		s.serveEcho(ctx, resp, req)
		return
	default:
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		err = s.badRouteError(msg, req.Method, req.URL.Path)
		s.writeError(ctx, resp, err)
		return
	}
}

func (s *userServer) serveEcho(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	header := req.Header.Get("Content-Type")
	i := strings.Index(header, ";")
	if i == -1 {
		i = len(header)
	}
	ctx = twirp.WithMethodOption(ctx, "foo")
	switch strings.TrimSpace(strings.ToLower(header[:i])) {
	case "application/json":
		s.serveEchoJSON(ctx, resp, req)
	case "application/protobuf":
		s.serveEchoProtobuf(ctx, resp, req)
	default:
		s.serveEchoForm(ctx, resp, req)
	}
}

func (s *userServer) serveEchoJSON(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "Echo")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(UserEchoReq)
	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	unmarshaler := protojson.UnmarshalOptions{DiscardUnknown: true}
	if err = unmarshaler.Unmarshal(body, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request json")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	if validerr := reqContent.validate(); validerr != nil {
		s.writeError(ctx, resp, twirp.InvalidArgumentError("argument", validerr.Error()))
		return
	}

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.User.Echo(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEchoResp and nil error while calling Echo. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *userServer) serveEchoProtobuf(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "Echo")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	buf, err := ioutil.ReadAll(req.Body)
	if err != nil {
		err = s.wrapErr(err, "failed to read request body")
		s.writeError(ctx, resp, twirp.InternalErrorWith(err))
		return
	}
	reqContent := new(UserEchoReq)
	if err = proto.Unmarshal(buf, reqContent); err != nil {
		err = s.wrapErr(err, "failed to parse request proto")
		twerr := twirp.NewError(twirp.InvalidArgument, err.Error())
		twerr = twerr.WithMeta("cause", fmt.Sprintf("%T", err))
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = twirp.WithRequest(ctx, reqContent)
	if validerr := reqContent.validate(); validerr != nil {
		s.writeError(ctx, resp, twirp.InvalidArgumentError("argument", validerr.Error()))
		return
	}

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.User.Echo(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEchoResp and nil error while calling Echo. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		respBytes, err = proto.Marshal(respContent)
		if err != nil {
			err = s.wrapErr(err, "failed to marshal proto response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/protobuf")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)
	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *userServer) serveEchoForm(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	var err error
	ctx = twirp.WithMethodName(ctx, "Echo")
	ctx, err = s.hooks.CallRequestRouted(ctx)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	err = req.ParseForm()
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(UserEchoReq)

	if v, ok := req.Form["msg"]; ok {
		reqContent.Msg = v[0]
	}
	ctx = twirp.WithRequest(ctx, reqContent)

	if validerr := reqContent.validate(); validerr != nil {
		s.writeError(ctx, resp, twirp.InvalidArgumentError("argument", validerr.Error()))
		return
	}

	// Call service method
	var respContent proto.Message
	var ok bool
	if respContent, ok = twirp.Response(ctx); !ok {
		func() {
			defer func() {
				// In case of a panic, serve a 500 error and then panic.
				if r := recover(); r != nil {
					s.writeError(ctx, resp, twirp.InternalError("Internal service panic"))
					panic(r)
				}
			}()
			respContent, err = s.User.Echo(ctx, reqContent)
		}()
	}

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}
	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *UserEchoResp and nil error while calling Echo. nil responses are not supported"))
		return
	}

	ctx = twirp.WithResponse(ctx, respContent)

	ctx = s.hooks.CallResponsePrepared(ctx)

	type httpBody interface {
		GetContentType() string
		GetData() []byte
	}

	var respBytes []byte
	var respStatus = http.StatusOK
	if body, ok := interface{}(respContent).(httpBody); ok {
		type httpStatus interface{ GetStatus() int32 }
		if statusBody, ok := interface{}(respContent).(httpStatus); ok {
			if status := statusBody.GetStatus(); status > 0 {
				respStatus = int(status)
			}
		}
		if contentType := body.GetContentType(); contentType != "" {
			resp.Header().Set("Content-Type", contentType)
		}
		respBytes = body.GetData()
	} else {
		marshaler := &protojson.MarshalOptions{UseProtoNames: true, EmitUnpopulated: true}
		if respBytes, err = marshaler.Marshal(respContent); err != nil {
			err = s.wrapErr(err, "failed to marshal json response")
			s.writeError(ctx, resp, twirp.InternalErrorWith(err))
			return
		}
		resp.Header().Set("Content-Type", "application/json")
	}

	ctx = twirp.WithStatusCode(ctx, respStatus)
	resp.WriteHeader(respStatus)

	if n, err := resp.Write(respBytes); err != nil {
		msg := fmt.Sprintf("failed to write response, %d of %d bytes written: %s", n, len(respBytes), err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		s.hooks.CallError(ctx, twerr)
	}
	s.hooks.CallResponseSent(ctx)
}

func (s *userServer) ServiceDescriptor() ([]byte, int) {
	return twirpFileDescriptor0SHA048826a37c6fed37f7cbc8ced86d84eadc9de82a, 0
}

func (s *userServer) ProtocGenTwirpVersion() string {
	return "v0.1.0"
}

var twirpFileDescriptor0SHA048826a37c6fed37f7cbc8ced86d84eadc9de82a = []byte{
	// 123 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2b, 0x2a, 0x48, 0xd6,
	0x2f, 0x2d, 0x4e, 0x2d, 0xd2, 0x2f, 0x33, 0x04, 0xd3, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42,
	0xec, 0x60, 0x76, 0x99, 0xa1, 0x92, 0x3c, 0x17, 0x77, 0x68, 0x71, 0x6a, 0x91, 0x6b, 0x72, 0x46,
	0x7e, 0x50, 0x6a, 0xa1, 0x90, 0x00, 0x17, 0x73, 0x6e, 0x71, 0xba, 0x04, 0xa3, 0x02, 0xa3, 0x06,
	0x67, 0x10, 0x88, 0xa9, 0xa4, 0xc0, 0xc5, 0x83, 0x50, 0x50, 0x5c, 0x80, 0xa9, 0xc2, 0xc8, 0x9a,
	0x8b, 0x05, 0xa4, 0x42, 0xc8, 0x98, 0x8b, 0x05, 0xa4, 0x4a, 0x48, 0x44, 0x0f, 0x6a, 0xb8, 0x1e,
	0x92, 0xc9, 0x52, 0xa2, 0x58, 0x44, 0x8b, 0x0b, 0x92, 0xd8, 0xc0, 0xee, 0x31, 0x06, 0x04, 0x00,
	0x00, 0xff, 0xff, 0x17, 0x00, 0x74, 0xed, 0xa9, 0x00, 0x00, 0x00,
}
